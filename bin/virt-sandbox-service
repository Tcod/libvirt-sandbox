#!/usr/bin/python -Es
#
# Authors: Dan Walsh <dwalsh@redhat.com>
#
# Copyright (C) 2012-2013 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

PROGNAME="virt-sandbox-service"

from gi.repository import LibvirtGObject
from gi.repository import LibvirtSandbox
from gi.repository import GLib
import gi
import os, sys, shutil, errno, stat
import exceptions
import rpm
from subprocess import Popen, PIPE, STDOUT
import gettext

if os.path.exists("/sys/fs/selinux"):
    import selinux
else:
    selinux = None

LibvirtGObject.init_object_check(None)
LibvirtSandbox.init_check(None)

gettext.bindtextdomain(PROGNAME, "/usr/share/locale")
gettext.textdomain(PROGNAME)
try:
    gettext.install(PROGNAME,
                    localedir="/usr/share/locale",
                    unicode=False,
                    codeset = 'utf-8')
except IOError:
    import __builtin__
    __builtin__.__dict__['_'] = unicode

class Container:
    IGNORE_DIRS        = [ "/var/run/", "/etc/logrotate.d/", "/etc/pam.d" ]
    DEFAULT_DIRS       = [ "/etc", "/var" ]
    PROFILE_FILES      = [ ".bashrc", ".bash_profile" ]
    CONFIG_PATH        = "/etc/libvirt-sandbox/services/"
    MACHINE_ID         = "/etc/machine-id"
    HOSTNAME           = "/etc/hostname"
    FUNCTIONS          = "/etc/rc.d/init.d/functions"
    ANACONDA_WANTS_PATH = "/usr/lib/systemd/system/anaconda.target.wants"
    MULTI_USER_WANTS_PATH = "/usr/lib/systemd/system/multi-user.target.wants"
    SYSINIT_WANTS_PATH = "/usr/lib/systemd/system/sysinit.target.wants"
    SOCKET_WANTS_PATH  = "/usr/lib/systemd/system/sockets.target.wants"
    MAKE_SYSTEM_DIRS   = [ "/var/lib/dhclient", "/var/lib/dbus", "/var/log", "/var/spool", "/var/cache", "/var/tmp", "/var/lib/nfs/rpc_pipefs", "/etc/rc.d/init.d"]
    BIND_SYSTEM_DIRS   = [ "/var", "/home", "/root", "/etc/systemd/system", "/etc/rc.d", "/usr/lib/systemd/system/basic.target.wants", "/usr/lib/systemd/system/local-fs.target.wants", ANACONDA_WANTS_PATH, MULTI_USER_WANTS_PATH, SYSINIT_WANTS_PATH, SOCKET_WANTS_PATH ]
    BIND_SYSTEM_FILES  = [ MACHINE_ID, "/etc/fstab", HOSTNAME ]
    LOCAL_LINK_FILES   = { SYSINIT_WANTS_PATH : [ "systemd-tmpfiles-setup.service" ] , SOCKET_WANTS_PATH : [ "dbus.socket", "systemd-journald.socket", "systemd-shutdownd.socket" ] }

    SELINUX_FILE_TYPE  = "svirt_lxc_file_t"
    DEFAULT_PATH       = "/var/lib/libvirt/filesystems"
    DEFAULT_IMAGE      = "/var/lib/libvirt/images/%s.raw"
    DEFAULT_UNIT       = "/etc/systemd/system/%s_sandbox.service"

    def __init__(self, name=None, uri = "lxc:///", path = DEFAULT_PATH, config=None, create=False):
        self.uri = uri
        self.copy = False
        self.use_image = False
        self.path = path
        self.conn = None
        self.image = None
        self.size = 10 * MB
        self.config = None
        self.unitfile = None
        self.unit_file_list = []
        self.name = name

        if name:
            config = self.get_config_path(name)
            self.dest = "%s/%s" % (self.path, name)

        if create:
            if config and os.path.exists(config):
                raise ValueError(["Container already exists"])

            self.config = LibvirtSandbox.ConfigService.new(name)
            return

        if config:
            try:
                self.config = LibvirtSandbox.Config.load_from_path(config)
                self.unitfile = self.get_unit_path()
            except GLib.GError, e:
                raise OSError(config + ": " + str(e))

    def __follow_units(self):
        unitst=""
        for i, src in self.unit_file_list:
            unitst += "ReloadPropagatedFrom=%s\n" % i

        return unitst

    def get_unit_path(self, name = None):
        if not name:
            name = self.get_name()
        return self.DEFAULT_UNIT % name

    def set_unit_file_list(self, unit_file_list):
        self.unit_file_list = unit_file_list

    def __get_sandboxed_service(self):
        return self.unit_file_list[0][0].split(".")[0]

    def __get_sandbox_target(self):
        if len(self.unit_file_list) > 1:
            raise ValueError(["Only Valid for single units"])
        return "%s_sandbox.target" %  self.__get_sandboxed_service()

    def __target(self):
        try:
            name = self.__get_sandbox_target()
            path = "/etc/systemd/system/" + name
            if not os.path.exists(path):
                fd = open(path, "w")
                fd.write("""
#  This target file is generated by virt-sandbox-service.
#  Use this target to start/stop all "%(NAME)s" sandbox services
#
#  virt-sandbox is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=%(NAME)s Sandbox Container Target
Documentation=man:virt-sandbox-service(1)

[Install]
WantedBy=multi-user.target
""" % { "NAME" : self.__get_sandboxed_service() })
            return "%s" % name
        except OSError:
            return ""

    def __create_system_unit(self):
        self.unitfile = self.get_unit_path()
        name = self.config.get_name()
        unit = r"""
[Unit]
Description=Secure Sandbox Container %(NAME)s
Requires=libvirtd.service
After=libvirtd.service
%(FOLLOW)s
[Service]
Type=simple
ExecStart=/usr/bin/virt-sandbox-service start %(NAME)s
ExecReload=/usr/bin/virt-sandbox-service reload -u %(RELOAD)s %(NAME)s
ExecStop=/usr/bin/virt-sandbox-service stop %(NAME)s

[Install]
WantedBy=%(TARGET)s
""" % { 'NAME':name, 'FOLLOW':self.__follow_units(), 'TARGET':self.__target(), 'RELOAD': " -u ".join(map(lambda x: x[0], self.unit_file_list)) }
        fd = open(self.unitfile, "w")
        fd.write(unit)
        fd.close()
        if selinux is not None:
            selinux.restorecon(self.unitfile)
        p = Popen(["/usr/bin/systemctl","enable", self.unitfile],stdout=PIPE, stderr=PIPE)
        p.communicate()
        if p.returncode and p.returncode != 0:
            raise OSError("Failed to enable %s unit file " %  self.unitfile)
        sys.stdout.write("Created unit file %s\n" %  self.unitfile)

    def __add_dir(self, newd):
        if newd in self.all_dirs:
            return
        for ignd in self.IGNORE_DIRS:
            if newd.startswith(ignd):
                return
        for defd in self.DEFAULT_DIRS:
            if newd.startswith(defd):
                self.all_dirs.append(newd)
                tmp_dirs = []
                for d in self.dirs:
                    if newd.startswith(d):
                        return
                    if not d.startswith(newd):
                        tmp_dirs.append(d)
                self.dirs = tmp_dirs
                self.dirs.append(newd)
                break;

    def __add_file(self, newf):
        if newf in self.files:
            return
        for d in self.IGNORE_DIRS:
            if newf.startswith(d):
                return
        for d in self.DEFAULT_DIRS:
            if newf.startswith(d):
                self.files.append(newf)
                break;

    def get_config_path(self, name = None):
        if not name:
            name = self.get_name()
        return self.CONFIG_PATH + name + ".sandbox"

    def get_filesystem_path(self, name = None):
        if not name:
            name = self.get_name()
        return self.DEFAULT_PATH + "/" + name

    def get_image_path(self, name = None):
        if not name:
            name = self.get_name()
        return self.DEFAULT_IMAGE % name

    def get_name(self):
        if self.config:
            return self.config.get_name()
        raise ValueError(["Name not configured"])

    def set_copy(self, copy):
        self.copy = copy

    def set_security(self, val):
        return self.config.set_security_opts(val)

    def add_network(self, val):
        return self.config.add_network_opts(val)

    def get_security_dynamic(self):
        return self.config.get_security_dynamic()

    def get_security_label(self):
        return self.config.get_security_label()

    def set_security_label(self):
        if selinux is None:
            return

        if self.image or self.get_security_dynamic():
            return

        selabel = self.get_security_label()
        if selabel is None:
            raise ValueError(["Missing security label configuration"])
        parts = selabel.split(":")
        if len(parts) != 5 and len(parts) != 4:
            raise ValueError(["Expected 5 parts in SELinux security label %s" % parts])

        if len(parts) == 5:
            selinux.chcon(self.dest, "system_u:object_r:%s:%s:%s" % (
                    self.SELINUX_FILE_TYPE, parts[3], parts[4]), True)
        else:
            selinux.chcon(self.dest, "system_u:object_r:%s:%s" % (
                    self.SELINUX_FILE_TYPE, parts[3]), True)

    def set_image(self, size):
        self.use_image = True
        self.size = size * MB

    def set_path(self, path):
        self.path = path

    def set_name(self, name):
        if self.config:
            raise ValueError(["Cannot modify Name"])
        self.dest = "%s/%s" % (self.path, self.name)
        self.config = LibvirtSandbox.ConfigService.new(name)

    def __extract_rpms(self):
        self.all_dirs = []
        self.dirs = []
        self.files = []

        self.ts = rpm.ts()

        for u, src in self.unit_file_list:
            self.__extract_rpm_for_unit(src)

    def __split_filename(self, filename):
        if filename[-4:] == '.rpm':
            filename = filename[:-4]

        archIndex = filename.rfind('.')
        arch = filename[archIndex+1:]

        relIndex = filename[:archIndex].rfind('-')
        rel = filename[relIndex+1:archIndex]

        verIndex = filename[:relIndex].rfind('-')
        ver = filename[verIndex+1:relIndex]

        epochIndex = filename.find(':')
        if epochIndex == -1:
            epoch = ''
        else:
            epoch = filename[:epochIndex]

        name = filename[epochIndex + 1:verIndex]
        return name, ver, rel, epoch, arch

    def __extract_rpm_for_unit(self, unitfile):
        mi = self.ts.dbMatch(rpm.RPMTAG_BASENAMES, unitfile)
        try:
            h = mi.next();
        except exceptions.StopIteration:
            raise ValueError(["Cannot find package containing %s" % unitfile])

        for fentry in h.fiFromHeader():
            fname = fentry[0]

            if os.path.isdir(fname):
                self.__add_dir(fname)
            if os.path.isfile(fname):
                self.__add_file(fname)

        srcrpm = h[rpm.RPMTAG_SOURCERPM]
        srcrpmbits = self.__split_filename(srcrpm)

        if srcrpmbits[0] == h[rpm.RPMTAG_NAME]:
            return

        mi = self.ts.dbMatch(rpm.RPMTAG_NAME, srcrpmbits[0])
        try:
            h = mi.next();
        except exceptions.StopIteration:
            raise ValueError(["Cannot find base package %s" % srcrpmbits[0]])

        for fentry in h.fiFromHeader():
            fname = fentry[0]

            if os.path.isdir(fname):
                self.__add_dir(fname)
            if os.path.isfile(fname):
                self.__add_file(fname)

    def __add_mount(self, source, dest):
        mount = LibvirtSandbox.ConfigMountHostBind.new(source, dest)
        self.config.add_mount(mount)

    def gen_hostname(self):
        fd=open(self.dest + self.HOSTNAME, "w")
        fd.write("%s\n" % self.name )
        fd.close()

    def gen_machine_id(self):
        uuid_fd = open("/proc/sys/kernel/random/uuid")
        uuid = uuid_fd.read().replace("-","").rstrip()
        uuid_fd.close()
        fd=open(self.dest + self.MACHINE_ID, "w")
        fd.write("%s\n" % uuid)
        fd.close()

        # Link /var/log/journal within the container to /var/log/journal/UUID
        # on host.  This will allow the hosts journalctl to easily read
        # containers journal information.
        jdir = "/var/log/journal/"
        jpath = jdir + uuid
        if not os.path.exists(self.dest + jpath):
            os.makedirs(self.dest + jpath)
        if not os.path.exists(jdir):
            os.makedirs(jdir)

        os.symlink(self.dest + jpath, jpath)

    def __gen_filesystems(self):
        if self.use_image:
            self.image = self.DEFAULT_IMAGE % self.get_name()
            mount = LibvirtSandbox.ConfigMountHostImage.new(self.image, self.dest)
            self.config.add_mount(mount)

        # 10 MB /run
        mount = LibvirtSandbox.ConfigMountRam.new("/run", 10 * 1024 * 1024);
        self.config.add_mount(mount)

        # 100 MB /tmp
        mount = LibvirtSandbox.ConfigMountRam.new("/tmp", 100 * 1024 * 1024);
        self.config.add_mount(mount)

        # 100 MB /tmp
        mount = LibvirtSandbox.ConfigMountRam.new("/dev/shm", 100 * 1024 * 1024);
        self.config.add_mount(mount)

        for d in self.BIND_SYSTEM_DIRS:
            if os.path.exists(d):
                source = "%s%s" % ( self.dest, d)
                self.__add_mount(source, d)

        for f in self.BIND_SYSTEM_FILES:
            if os.path.exists(f):
                source = "%s%s" % ( self.dest, f)
                self.__add_mount(source, f)

        for d in self.dirs:
            found = False
            # Dont add dirs whos parents are in SYSTEM_DIRS
            for s in self.BIND_SYSTEM_DIRS:
                if d.startswith(s):
                    found = True
                    break
            if not found:
                source = "%s%s" % ( self.dest, d)
                self.__add_mount(source, d)

    def __get_init_path(self):
        return "%s/%s/init" % (self.path, self.get_name())

    def __create_container_unit(self, src, dest, unit):
            fd = open(dest + "/" + unit, "w")
            fd.write(""".include %s
[Service]
PrivateTmp=false
PrivateNetwork=false
""" % src )
            fd.close()

    def __fix_stat(self, f):
        try:
            s = os.stat(f)
            path = "%s%s" % (self.dest, f)
            os.chown(path, s.st_uid, s.st_gid)
            os.chmod(path, s.st_mode)
        except OSError, e:
            if not e.errno == errno.ENOENT:
                raise e

    def __fix_protection(self):
        l = len(self.dest)
        for root, dirs, files in os.walk(self.dest):
            for f in files:
                dest = root + "/" + f
                self.__fix_stat(dest[l:])
            for d in dirs:
                dest = root + "/" + d
                self.__fix_stat(dest[l:])

    def makedirs(self, d):
        try:
            path = "%s%s" % (self.dest, d)
            os.makedirs(path)
        except OSError, e:
            if not e.errno == errno.EEXIST:
                raise e

    def makefile(self, f):
        self.makedirs(os.path.dirname(f))
        try:
            path = "%s%s" % (self.dest, f)
            fd=open(path, "w")
            fd.close()
        except OSError, e:
            if not e.errno == errno.EEXIST:
                raise e

    def __gen_content(self):
        if self.copy:
            for d in self.dirs:
                shutil.copytree(d, "%s%s" % (self.dest, d), symlinks=True)
            for f in self.files:
                self.makedirs(os.path.dirname(f))
                shutil.copy(f, "%s%s" % (self.dest, f))
        else:
            for d in self.all_dirs:
                self.makedirs(d)
            for f in self.files:
                self.makedirs(os.path.dirname(f))
                self.makefile(f)

        for d in self.BIND_SYSTEM_DIRS + self.MAKE_SYSTEM_DIRS:
            self.makedirs(d)

        for f in self.BIND_SYSTEM_FILES:
            self.makefile(f)

        shutil.copy(self.FUNCTIONS, "%s%s" % (self.dest, self.FUNCTIONS))

        self.gen_machine_id()

        self.gen_hostname()

        for k in self.LOCAL_LINK_FILES:
            for d in self.LOCAL_LINK_FILES[k]:
                src = "../%s" % ( d)
                dest = "%s%s/%s" % ( self.dest, k, d)
                os.symlink(src,dest)

        unitdir = "/etc/systemd/system"
        tgtdir = unitdir + "/multi-user.target.wants"

        self.makedirs(unitdir)
        self.makedirs(tgtdir)
        os.symlink("/run", self.dest + "/var/run")

        for i, src in self.unit_file_list:
            self.__create_container_unit(src, self.dest + unitdir, i)
            os.symlink("../" + i, self.dest + tgtdir + "/" + i)

        tgtfile = unitdir + "/multi-user.target"
        try:
            fd = open(self.dest + tgtfile, "w")
            fd.write("[Unit]\n")
            fd.write("Description=Sandbox multi-user target\n")
            fd.close()
        except OSError, e:
            if not e.errno == errno.EEXIST:
                raise e

        for p in self.PROFILE_FILES:
            profile = "/etc/skel/" + p
            shutil.copy(profile, self.dest + "/root/")

        self.__fix_protection()

    def __umount(self):
        p = Popen(["/bin/umount", self.dest])
        p.communicate()
        if p.returncode and p.returncode != 0:
            raise OSError("Failed to unmount image %s from %s " %  (self.image, self.dest))

    def __create_image(self):
        fd = open(self.image, "w")
        fd.truncate(self.size)
        fd.close()
        p = Popen(["/sbin/mkfs","-F", "-t", "ext4", self.image],stdout=PIPE, stderr=PIPE)
        p.communicate()
        if p.returncode and p.returncode != 0:
            raise OSError("Failed to build image %s" % self.image )

        p = Popen(["/bin/mount", self.image, self.dest])
        p.communicate()
        if p.returncode and p.returncode != 0:
            raise OSError("Failed to mount image %s on %s " %  (self.image, self.dest))

    def save_config(self):
        config = self.get_config_path()
        if os.path.exists(config):
            os.remove(config)
        self.config.save_to_path(config)
        if selinux is not None:
            selinux.restorecon(config)
        sys.stdout.write("Created sandbox config %s\n" % config)

    def __get_image_path(self):
            mounts = self.config.get_mounts()
            for m in mounts:
                if type(m) != LibvirtSandbox.ConfigMountHostImage:
                    continue

                if m.get_target() == self.dest:
                    return m.get_source()
            return None

    def _delete(self):
        # Should be stored in config
        try:
            fd=open(self.dest + self.MACHINE_ID, "r")
            uuid = fd.read().rstrip()
            fd.close()
            jpath = "/var/log/journal/" + uuid
            if os.path.exists(jpath):
                os.remove(jpath)
        except Exception, e:
            pass

        if os.path.exists(self.dest):
            shutil.rmtree(self.dest)
            mount_path = self.__get_image_path()
            if mount_path:
                os.remove(mount_path)

        config = self.get_config_path()
        if os.path.exists(config):
            os.remove(config)

        image = self.get_image_path()
        if os.path.exists(image):
            os.remove(image)

        if self.unitfile is not None and os.path.exists(self.unitfile):
            p = Popen(["/usr/bin/systemctl","disable", self.unitfile],stdout=PIPE, stderr=PIPE)
            p.communicate()
            if p.returncode and p.returncode != 0:
                raise OSError("Failed to disable %s unit file " %  self.unitfile)
            fd = open(self.unitfile,"r")
            recs = fd.readlines()
            fd.close()
            # Attempt to extract target file
            target = None
            for i in recs:
                if i.startswith("WantedBy="):
                    target = "/etc/systemd/system/%s" % i.split("=")[1][:-1]
            os.remove(self.unitfile)
            # If last target remove target file
            if target:
                if not os.path.exists(target + ".wants"):
                    os.remove(target)

    def delete(self):
        # Stop service if it is running
        try:
            self.stop()
        except:
            pass

        self._delete()

    def _create(self):
        self.__connect()
        self.config.set_shell(True)
        self.config.set_boot_target("multi-user.target")
        self.__extract_rpms()
        self.__gen_filesystems()
        os.mkdir(self.dest)
        if self.image:
            self.__create_image()
            self.__gen_content()
            self.__umount()
            sys.stdout.write("Created sandbox container image %s\n" % self.image)
        else:
            self.__gen_content()
            sys.stdout.write("Created sandbox container dir %s\n" % self.dest)
        self.set_security_label()
        self.save_config()
        self.__create_system_unit()

    def create(self):
        if os.path.exists(self.dest):
            raise OSError("%s already exists" % self.dest)

        try:
            self._create()
        except Exception, e:
            try:
                self._delete()
            except Exception, e2:
                pass
            raise e

    def reload(self, unitfiles):
        #
        # Reload Container
        #
        class Args:
            command = []
            noseclabel = None
            name = self.name
            uri = self.uri
        args = Args()
        args.command = [ "systemctl", "reload" ] + map(lambda x: x[0], unitfiles)
        execute(args)

    def __connect(self):
        if not self.conn:
            self.conn=LibvirtGObject.Connection.new(self.uri)
            self.conn.open(None)

    def __disconnect(self):
        if self.conn:
            self.conn.close()
            self.conn = None

    def running(self):
        def closed(obj, error):
            self.loop.quit()
        try:
            self.__connect()
            context = LibvirtSandbox.ContextService.new(self.conn, self.config)
            context.attach()
            self.__disconnect()
            return 1
        except GLib.GError, e:
            return 0

    def start(self):
        def closed(obj, error):
            self.loop.quit()

        try:
            self.__connect()
            context = LibvirtSandbox.ContextService.new(self.conn, self.config)
            context.start()
            console = context.get_log_console()
            console.connect("closed", closed)
            console.attach_stderr()
            self.loop = GLib.MainLoop()
            self.loop.run()
            try:
                console.detach()
            except:
                pass
            try:
                context.stop()
            except:
                pass
        except GLib.GError, e:
            raise OSError(str(e))

    def stop(self):
        try:
            self.__connect()
            context = LibvirtSandbox.ContextService.new(self.conn, self.config)
            context.attach()
            context.stop()
        except GLib.GError, e:
            raise OSError(str(e))

    def connect(self):
        def closed(obj, error):
            self.loop.quit()

        try:
            self.__connect()
            context = LibvirtSandbox.ContextService.new(self.conn, self.config)
            context.attach()
            console = context.get_shell_console()
            console.connect("closed", closed)
            console.attach_stdio()
            self.loop = GLib.MainLoop()
            self.loop.run()
            try:
                console.detach()
            except:
                pass
        except GLib.GError, e:
            raise OSError(str(e))

    def execute(self, command):
        def closed(obj, error):
            self.loop.quit()

        try:
            self.__connect()
            context = LibvirtSandbox.ContextService.new(self.conn, self.config)
            context.attach()
            console = context.get_shell_console()
            console.connect("closed", closed)
            console.attach_stdio()
            print "not currently implemented"
            console.detach()
            return
            self.loop = GLib.MainLoop()
            self.loop.run()
            try:
                console.detach()
            except:
                pass
        except GLib.GError, e:
            raise OSError(str(e))

MB = int(1000000)

def delete(args):
    container = Container(args.name)
    container.delete()

def create(args):
    container = Container(name = args.name, create = True)
    container.set_copy(args.copy)
    if args.network:
        for net in args.network:
            container.add_network(net)
    if args.security:
        container.set_security(args.security)
    container.set_unit_file_list(args.unitfiles)

    if args.imagesize:
        container.set_image(args.imagesize)

    container.create()

def usage(parser, msg):
    parser.print_help()

    sys.stderr.write("\n%s\n" % msg)
    sys.stderr.flush()
    sys.exit(1)

def sandbox_list(args):
    import glob
    container = Container()
    g = glob.glob(container.CONFIG_PATH + "*.sandbox")
    g.sort()
    for gc in g:
        try:
            c = Container(config = gc)
            if args.running:
                if c.running():
                    print c.get_name()
            else:
                print c.get_name()

        except OSError, e:
            print "Invalid container %s: %s", (gc, e)


def sandbox_reload(args):
    config = read_config(args.name)
    container = Container(uri = args.uri, config = config)
    container.reload(args.unitfiles)

def start(args):
    os.execl("/usr/libexec/virt-sandbox-service-util", "virt-sandbox-service-util","-s", args.name)
#    container = Container(args.name, args.uri)
#    container.start()

def stop(args):
    os.execl("/usr/libexec/virt-sandbox-service-util", "virt-sandbox-service-util","-S", args.name)
#    container = Container(args.name, args.uri)
#    container.stop()

def connect(args):
    print """\
Connected to %s.
Type 'Ctrl + ]' to detach from the console.
""" % ( args.name )
    os.execl("/usr/libexec/virt-sandbox-service-util", "virt-sandbox-service-util","-a", args.name)
#    container = Container(args.name, args.uri)
#    container.connect()

#
# Search Path for command to execute within the container.
#
def fullpath(cmd):
    for i in [ "/", "./", "../" ]:
        if cmd.startswith(i):
            return cmd
    for i in  os.environ["PATH"].split(':'):
        f = "%s/%s" % (i, cmd)
        if os.access(f, os.X_OK):
            return f
    return cmd

def execute(args):
    myexec = [ "virsh", "-c", "lxc:///", "lxc-enter-namespace" ]
#    myexec = [ "virt-sandbox-service-util", "execute" ]
    if args.noseclabel:
        myexec.append("--noseclabel")
    myexec.extend([ args.name, "--", fullpath(args.command[0])] +  args.command[1:])
    os.execv("/usr/bin/virsh", myexec)
#    myexec.extend( "-e", cmd, args.name ]
#    os.execv("/usr/libexec/virt-sandbox-service-util", myexec)

def clone(args):
    container = Container(args.source, args.uri)
    fd = open(container.get_config_path(),"r")
    recs = fd.read()
    fd.close()
    old_path = container.get_filesystem_path()
    new_path = container.get_filesystem_path(args.dest)
    newrec = recs.replace(old_path + "/", new_path + "/")
    newrec = newrec.replace("name=" + args.source, "name=" + args.dest)
    old_image_path = container.get_image_path()
    if os.path.exists(old_image_path):
        new_image_path = container.get_image_path(args.dest)
        newrec = newrec.replace(old_image_path, new_image_path)
        shutil.copy(old_image_path, new_image_path)
        sys.stdout.write("Created sandbox container image %s\n" % new_image_path)
        os.mkdir(new_path)
    else:
        shutil.copytree(old_path, new_path, symlinks=True)
        sys.stdout.write("Created sandbox container dir %s\n" % new_path)

    fd = open(container.get_unit_path())
    recs = fd.read()
    fd.close()

    fd = open(container.get_unit_path(args.dest), "wx")
    fd.write(recs.replace(args.source, args.dest))
    fd.close()

    new_unit = container.get_config_path(args.dest)
    fd = open(new_unit,"wx")
    fd.write(newrec)
    fd.close()
    sys.stdout.write("Created unit file %s\n" % new_unit)

    container = Container(args.dest, args.uri)
    if args.security:
        container.set_security(args.security)
    container.gen_machine_id()
    container.gen_hostname()
    container.set_security_label()
    container.save_config()

import argparse
class SizeAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, int(values))

class CheckUnit(argparse.Action):
    def __call__(self, parser, namespace, value, option_string=None):
        def check_unit(unit):
            src = "/etc/systemd/system/" + unit
            if os.path.exists(src):
                return src
            src = "/lib/systemd/system/" + unit
            if os.path.exists(src):
                return src
            return None
        src = check_unit(value)
        if not src:
            src = check_unit(value + ".service")
            if src:
                value = value + ".service"
            else:
                raise OSError("Requested unit %s does not exist" % value)

        unitfiles = getattr(namespace, self.dest)
        if unitfiles:
            unitfiles.append((value, src))
        else:
            unitfiles = [ (value, src) ]
        setattr(namespace, self.dest, unitfiles)

class SetNet(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        nets = getattr(namespace, self.dest)
        if nets:
            nets.append(values)
        else:
            nets = [values]
        setattr(namespace, self.dest, nets)

def requires_name(parser):
    parser.add_argument("name",
                        help=_("name of the sandbox container"))

def default_security_opts():
    if selinux is None:
        return None

    # XXX vary per URI for kvm/qemu/lxc.
    # XXX generate a random category
    return "static,label=system_u:system_r:svirt_lxc_net_t:s0"

def gen_create_args(subparser):
    parser = subparser.add_parser("create",
                                  help=_("create a sandbox container"))

    parser.add_argument("-u", "--unitfile", required=True,
                        action=CheckUnit,
                        dest="unitfiles",
                        help=_("Systemd Unit file to run within the sandbox container"))
    parser.add_argument("-p", "--path", dest="path",  default=None,
                        help=_("select path to store sandbox content.  Default: %s") % c.DEFAULT_PATH)

    parser.add_argument("-s", "--security", dest="security",
                        default=default_security_opts(),
                        help=_("Specify the security model configuration for the sandbox: Defaults to dynamic"))
    parser.add_argument("-N", "--network", dest="network",
                        action=SetNet,
                        help=_("Specify the network configuration"))

    image = parser.add_argument_group("Create On Disk Image File")

    image.add_argument("-i", "--imagesize", dest="imagesize", default = None,
                       action=SizeAction,
                       help=_("create image of this many megabytes."))
    parser.add_argument("-C", "--copy", default=False,
                        action="store_true",
                        help=_("copy content from /etc and /var directories that will be mounted within the sandbox"))
    requires_name(parser)

    parser.set_defaults(func=create)

def gen_connect_args(subparser):
    parser = subparser.add_parser("connect",
                                  help=_("Connect to a sandbox container"))
    requires_name(parser)
    parser.set_defaults(func=connect)

def gen_execute_args(subparser):
    parser = subparser.add_parser("execute",
                                  help=("Execute a command within a sandbox container"))
    parser.add_argument("-N", "--noseclabel", dest="noseclabel",
                        default=False, action="store_true",
                        help=_("do not modify the label of the executable process.  By default all commands execute with the label of the sandbox"))
    requires_name(parser)
    parser.add_argument("command", nargs="+",
                        help=_("command to execute within the container"))
    parser.set_defaults(func=execute)

def gen_start_args(subparser):
    parser = subparser.add_parser("start",
                                   help=_("Start a sandbox container"))
    requires_name(parser)
    parser.set_defaults(func=start)

def gen_stop_args(subparser):
    parser = subparser.add_parser("stop",
                                   help=_("Stop a sandbox container"))
    requires_name(parser)
    parser.set_defaults(func=stop)

def gen_reload_args(subparser):
    parser = subparser.add_parser("reload",
                                   help=_("Reload a running sandbox container"))
    parser.add_argument("-u", "--unitfile", required=True,
                        action=CheckUnit, dest="unitfiles",
                        help=_("Systemd Unit file to reload within the sandbox container"))
    requires_name(parser)
    parser.set_defaults(func=sandbox_reload)

def gen_clone_args(subparser):
    parser = subparser.add_parser("clone",
                                         help=_("Clone an existing sandbox container"))
    parser.set_defaults(func=clone)
    parser.add_argument("-s", "--security", dest="security",
                        default=default_security_opts(),
                        help=_("Specify the security model configuration for the sandbox: Defaults to dynamic"))

    parser.add_argument("source",
                        help=_("source sandbox container name"))
    parser.add_argument("dest",
                        help=("dest name of the new sandbox container"))

def gen_delete_args(subparser):
    parser = subparser.add_parser("delete",
                                   help=_("Delete a sandbox container"))
    requires_name(parser)
    parser.set_defaults(func=delete)

def gen_list_args(subparser):
    parser = subparser.add_parser("list",
                                  help=_("List all sandbox container"))
    parser.add_argument("-r", "--running", dest="running",
                        default=False, action="store_true",
                        help=_("list only running sandbox containers"))
    parser.set_defaults(func=sandbox_list)

if __name__ == '__main__':
    c = Container()

    parser = argparse.ArgumentParser(description='Sandbox Container Tool')
    parser.add_argument("-c", "--connect", required=False, dest="uri",  default="lxc:///",
                        help=_("libvirt connection URI to use (lxc:/// [default] or qemu:///session)"))

    subparser = parser.add_subparsers(help=_("commands"))
    gen_create_args(subparser)
    gen_clone_args(subparser)
    gen_connect_args(subparser)
    gen_delete_args(subparser)
    gen_execute_args(subparser)
    gen_list_args(subparser)
    gen_reload_args(subparser)
    gen_start_args(subparser)
    gen_stop_args(subparser)

    try:
        args = parser.parse_args()
        args.func(args)
        sys.exit(0)
    except KeyboardInterrupt, e:
        sys.exit(0)
    except ValueError, e:
        for line in e:
            for l in line:
                sys.stderr.write("%s: %s\n" % (sys.argv[0], l))
        sys.stderr.flush()
        sys.exit(1)
    except IOError, e:
        sys.stderr.write("%s: %s: %s\n" % (sys.argv[0], e.filename, e.strerror))
        sys.stderr.flush()
        sys.exit(1)
    except OSError, e:
        sys.stderr.write("%s: %s\n" % (sys.argv[0], e))
        sys.stderr.flush()
        sys.exit(1)
